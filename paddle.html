<!doctype html>
<html lang='en-us'>
	<head>
		<meta charset='utf-8' />
		<link href='stylesheet.css' rel='stylesheet' type='text/css' />
		<title>Paddle ← CS & BIC</title>
	</head>
	<body>
		<header>
			<h1><a href='index.html'>CS & BIC</a> → Paddle</h1>
		</header>
		<h2>Synopsis</h2>
		<p><dfn>Paddle</dfn> is a utility for padding data to the closest length that is a multiple of the provided block amount.</p>
		<h2>Specification</h2>
		<h3>Padding</h3>
		<ol>
			<li>The data has a byte with a value of one appended to it.</li>
			<li>The data has zero-ed bytes appended to it until the length of the data is a multiple of the block.</li>
		</ol>
		<h3>Unpadding</h3>
		<p>Remove padding by removing zero-ed bytes from the end of the data until the byte with a value of one is found.</p>
		<h2>Distribution</h2>
		<p>Paddle is released as a <a href='#'>package</a> written in <a href='https://golang.org'>Go</a> under the MIT License. Paddle is currently at version 1.0.0, and will likely undergo an update that adds a constant-time implementation in order to be resistant to side-channel attacks.</p>
		<h2>Example</h2>
<pre><code>package main
import (
	"fmt"
	"yourmodule/paddle"
)
func main() {
	block := 100
	data := []byte("Hello, world!")
	fmt.Println("ORIGINAL LENGTH: ", len(data))
	fmt.Println("ORIGINAL: ", data)
	data, issue := paddle.Pad(block, data)
	if issue != nil {
		panic(issue)
	}
	fmt.Println("PADDED LENGTH: ", len(data))
	fmt.Println("PADDED: ", data)
	data, issue = paddle.Unpad(data)
	if issue != nil {
		panic(issue)
	}
	fmt.Println("UNPADDED LENGTH: ", len(data))
	fmt.Println("UNPADDED: ", data)
}</code></pre>
	</body>
</html>
